<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Man Behind the Tree</title>
    <link rel="icon" type="image/x-icon" href="ice.ico">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* ... existing styles ... */

        /* --- Existing styles omitted for brevity, do not remove them! --- */

        /* === CREEPY GLITCHED WINGDINGS FINAL LINE === */
        .final-creepy-line {
            display: flex;
            justify-content: center;
            gap: 0.08em;
            margin-top: 16px;
            margin-bottom: 8px;
            font-size: 2.4em;
            font-family: 'VT323', monospace;
            letter-spacing: 0.13em;
            position: relative;
            z-index: 20;
            user-select: none;
        }
        .final-creepy-line .char {
            display: inline-block;
            position: relative;
            transition: 
                color 0.23s cubic-bezier(.5,2,.3,1), 
                filter 0.12s, 
                transform 0.13s cubic-bezier(.5,2,.3,1);
            /* Glitch shadow for normal state */
            text-shadow: 1px 0 5px #000, 0 1px 8px #ff0000;
        }
        .final-creepy-line .shake {
            animation: final-creepy-shake 0.38s cubic-bezier(.5,2,.3,1);
        }
        .final-creepy-line .glitch {
            color: #ff0000;
            filter: blur(0.8px) contrast(1.08);
            text-shadow: 
                2px 0 #fff, 
                -2px 0 #00fff2,
                0 0 8px #ff0000;
            animation: final-creepy-glitch 0.38s cubic-bezier(.5,2,.3,1);
        }
        @keyframes final-creepy-shake {
            0% { transform: translate(0,0) skewX(0deg); }
            23% { transform: translate(-2px, 1px) skewX(-2deg); }
            38% { transform: translate(1.5px, -2px) skewX(1deg);}
            63% { transform: translate(-1px, 2.2px) skewX(-3deg);}
            80% { transform: translate(2px, -1.5px) skewX(2deg);}
            100% { transform: translate(0,0) skewX(0deg);}
        }
        @keyframes final-creepy-glitch {
            0% { filter: blur(0.8px) contrast(1.08); color: #ff0000;}
            55% { filter: blur(2.4px) contrast(1.3); color: #fff;}
            85% { filter: blur(2.7px) contrast(1.4); color: #00fff2;}
            100% { filter: blur(0.8px) contrast(1.08); color: #ff0000;}
        }
        .final-creepy-line .wingdings {
            font-family: 'Wingdings', 'Wingdings 1', 'Webdings', 'Symbola', cursive !important;
            letter-spacing: 0.21em;
            color: #c6baff !important;
            filter: contrast(1.1) grayscale(0.45) brightness(1.1);
            text-shadow: 0 0 10px #222, 1.5px 0 6px #fff, 0 1.5px 8px #8e00ff;
            transition: color 0.15s, filter 0.1s;
        }
        .final-creepy-line .whisper {
            opacity: 0.56;
            color: #fffbe8 !important;
            filter: blur(0.7px);
        }
        /* Optional: subtle fade for the whole line during swaps */
        .final-creepy-line.fading {
            opacity: 0.75;
            filter: blur(1.5px) grayscale(0.15);
            transition: opacity 0.24s, filter 0.2s;
        }

        /* Hide the fallback text for accessibility but keep it for screen readers */
        .final-creepy-line .sr-only {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="snow" id="snow"></div>
    
    <div class="container">
        <h1 class="title glitch"><span class="tree-emoji">🌲</span> "The Man Behind the Tree"</h1>
        <div class="subtitle">POV: Kris | Genre: Psychological Horror | Deltarune Fan Story</div>
        
        <div class="story-content">
            <p><span class="glitch-emphasis">You shouldn't be here.</span></p>
            <p>But your feet are already in the dirt. Knees bent slightly. Hands slack. Bark under your nails. You don't remember walking up to the tree, but here it is. Here you are.</p>
            <p>The air is quiet, except it isn't. Something hums. Or buzzes. Or rings.</p>
            <p>You blink.</p>
            <p><span class="glitch-thought">"There is a man here."</span></p>
            <p>That thought doesn't belong to you. Not really. But it's there, like it's always been there, stapled to the back of your eyes. You're standing in front of the big pine behind the school[...]</p>
            <p><span class="glitch-thought">"There is a man here."</span></p>
            <p>Your hands are cold. One of them is holding something.</p>
            <p><span class="glitch-emphasis">You don't look.</span></p>
            <p><span class="glitch-emphasis">You can't look.</span></p>
            <p>There's bark beneath your fingertips again. You were scratching. You think. Or maybe clawing. There's a small wound. Yours? Hers?</p>
            <p><span class="glitch-memory">You were crying.</span></p>
            <p>No… no. That's not right.</p>
            <p><span class="glitch-memory">She was crying.</span></p>
            <p>Yes. She was. Behind you. In front of you. By the tree. It's hard to say. The sound's long gone, but the echo's still fresh, like steam in winter.</p>
            <p>The grass is bent where she stood. You think it was her. <span class="glitch-memory">Antlers like candle branches. Shoulders curled in.</span> She kept looking at you, but you couldn't [...]</p>
            <p><span class="glitch-emphasis">Or maybe you let go.</span></p>
            <p>You can't stop looking at the tree.</p>
            <p>There's a shape behind it. Not moving. Not breathing. Not—</p>
            <p><span class="glitch">No, wait.</span></p>
            <p><span class="glitch-memory">It was moving. It was breathing.</span></p>
            <p>You don't remember seeing its face. But you remember it having one. You remember the way it pressed against the bark, like it wanted to disappear into it. Like it was listening. Or wait[...]</p>
            <p><span class="glitch-memory">Dess was afraid. She tugged your sleeve.</span> <span class="glitch-emphasis">You didn't move.</span></p>
            <p>You don't remember why you didn't move.</p>
            <p>Maybe you wanted to see what the man would do.</p>
            <p><span class="glitch-emphasis">You don't remember what he did.</span></p>
            <p>Just—</p>
            <p><span class="glitch">Darkness. Like something closing. Like a lid. Like an eye.</span><br>
            And then…</p>
            <p>You were standing alone.</p>
            <p>Your hand was empty. The wind was blowing. The sun was lower than it should've been.<br>
            Your throat was dry and tight.</p>
            <p><span class="glitch-memory">No antlers. No guitar. No laughter.</span><br>
            Just the tree. And you.</p>
            <p><span class="glitch-thought">"Well. There was a man here."</span></p>
            <p>You're still not sure if that means he's gone.</p>
            <p>Or if he's just somewhere else now.</p>
            <p><span class="glitch-emphasis">Behind another tree.</span></p>
            <!-- FINAL CREEPY LINE START -->
            <div class="final-creepy-line" id="finalLine" aria-live="polite">
                <!-- Accessible fallback for screen readers -->
                <span class="sr-only">Behind you.</span>
                <!-- Each character is separated so we can animate/shake/glitch them individually -->
                <span class="char">B</span>
                <span class="char">e</span>
                <span class="char">h</span>
                <span class="char">i</span>
                <span class="char">n</span>
                <span class="char">d</span>
                <span class="char">&nbsp;</span>
                <span class="char">y</span>
                <span class="char">o</span>
                <span class="char">u</span>
                <span class="char">.</span>
            </div>
            <!-- FINAL CREEPY LINE END -->
        </div>
    </div>

    <!-- Music Player Structure, adapted for consistency with index.html -->
    <audio id="backgroundMusic" loop preload="auto">
        <source src="flashback.ogg" type="audio/ogg">
        Your browser does not support the audio element.
    </audio>

    <div class="music-controls">
        <button id="musicToggle" class="music-btn">♫ Music: OFF</button>
        <input type="range" id="volumeSlider" min="0" max="100" value="30" class="volume-slider">
        <span class="volume-label">Vol</span>
    </div>

    <div class="music-info" id="musicInfo" data-text="♪ i can hear you.... please... help me...: found.ogg">
        ♪ i can hear you.... please... help me...: found.ogg
        <div class="music-info-scanlines"></div>
        <div class="music-info-static"></div>
    </div>

    <script>
        // ==== Final Creepy Line Animation ====
        // "Behind you." => [Wingdings], "Find Her.", "Help Me.", then back, with per-letter shakes and glitch

        // Unicode Wingdings mapping for "Behind you."
        // Fallbacks will show normal letters if Wingdings is missing.
        const wingdingsMap = {
            'B': '\uF0A5', // hand pointing right
            'e': '\uF076', // eye
            'h': '\uF0B1', // clock (hourglass)
            'i': '\uF06E', // exclamation
            'n': '\uF0E0', // bell
            'd': '\uF0A6', // hand pointing left
            ' ': '\u00A0',
            'y': '\uF0C6', // skull
            'o': '\uF0A7', // thumb up
            'u': '\uF018', // smiley
            '.': '\uF0FB'  // black circle
        };
        // For fallback, just in case, fallback to normal letter.
        function toWingdings(char) {
            return wingdingsMap[char] || char;
        }

        const finalLine = document.getElementById('finalLine');
        const charSpans = finalLine.querySelectorAll('.char');
        // The three message states:
        const states = [
            { // 0: Normal
                text: "Behind you.",
                mode: "normal"
            },
            { // 1: Wingdings
                text: "Behind you.",
                mode: "wingdings"
            },
            { // 2: Glitch "Find Her."
                text: "Find Her.",
                mode: "glitch"
            },
            { // 3: Glitch "Help Me."
                text: "Help Me.",
                mode: "glitch"
            }
        ];

        // Track current state
        let currentState = 0;
        let lastSwapTime = Date.now();

        // Helper to update the display
        function updateFinalLine(stateIdx, fade = false) {
            const state = states[stateIdx];
            if (fade) {
                finalLine.classList.add('fading');
            } else {
                finalLine.classList.remove('fading');
            }
            // If text length is different, replace spans
            if (charSpans.length !== state.text.length) {
                finalLine.innerHTML = '<span class="sr-only">' + state.text + '</span>';
                for (let c of state.text) {
                    const span = document.createElement('span');
                    span.className = 'char';
                    span.textContent = c;
                    finalLine.appendChild(span);
                }
            } else {
                // Otherwise just update letters
                finalLine.querySelector('.sr-only').textContent = state.text;
                charSpans.forEach((span, i) => {
                    span.textContent = state.text[i];
                });
            }
            // Apply per-letter styles
            const updatedSpans = finalLine.querySelectorAll('.char');
            updatedSpans.forEach((span, i) => {
                span.classList.remove('wingdings', 'glitch', 'shake', 'whisper');
                // Wingdings state
                if (state.mode === 'wingdings') {
                    // Only apply to non-space
                    if (state.text[i] !== ' ') {
                        span.classList.add('wingdings');
                        span.textContent = toWingdings(state.text[i]);
                    }
                }
                // Glitch state
                if (state.mode === 'glitch') {
                    // Each letter gets shake and glitch
                    if (state.text[i] !== ' ') {
                        span.classList.add('glitch', 'shake');
                        // Sometimes fade a letter for extra effect
                        if (Math.random() > 0.7) span.classList.add('whisper');
                    } else {
                        span.classList.remove('glitch', 'shake', 'whisper');
                    }
                }
            });
        }

        // Animate per-letter jitters randomly in normal and wingdings states
        function jitterFinalLine() {
            const spans = finalLine.querySelectorAll('.char');
            if (currentState === 0 || currentState === 1) {
                spans.forEach(span => {
                    // Low chance of shake on each frame
                    if (Math.random() > 0.91 && span.textContent.trim() !== '') {
                        span.classList.add('shake');
                        setTimeout(() => span.classList.remove('shake'), 140 + Math.random()*120);
                    }
                });
            }
        }

        // Swap states on a timer
        let swapTimer = null;
        function nextFinalState() {
            // Weighted: Main state (Behind you.) is longer, glitches and wingdings are flashes
            let delay;
            if (currentState === 0) { // Normal to Wingdings
                currentState = 1;
                delay = 650 + Math.random()*600;
            } else if (currentState === 1) { // Wingdings to Glitch "Find Her."
                currentState = 2;
                delay = 240 + Math.random()*200;
            } else if (currentState === 2) { // "Find Her." to "Help Me."
                currentState = 3;
                delay = 180 + Math.random()*140;
            } else if (currentState === 3) { // "Help Me." to Normal
                currentState = 0;
                delay = 2600 + Math.random()*2000;
            }
            // Fade out/in between certain swaps for creepiness
            let fade = (currentState === 1 || currentState === 0);
            updateFinalLine(currentState, fade);
            swapTimer = setTimeout(nextFinalState, delay);
        }
        // Start animation
        updateFinalLine(0);
        swapTimer = setTimeout(nextFinalState, 2600 + Math.random()*2200);
        setInterval(jitterFinalLine, 68);

        // --- The rest of your script remains unchanged. ---

        // Create falling snow
        function createSnow() {
            const snow = document.getElementById('snow');
            const snowflakeCount = 80;
            
            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                
                // Mix of different snowflake characters for variety
                const snowflakeTypes = ['❄', '❅', '❆', '*', '·', '✦'];
                snowflake.innerHTML = snowflakeTypes[Math.floor(Math.random() * snowflakeTypes.length)];
                
                snowflake.style.left = Math.random() * 100 + '%';
                snowflake.style.animationDuration = (Math.random() * 4 + 3) + 's';
                snowflake.style.animationDelay = Math.random() * 5 + 's';
                
                // Add slight horizontal drift
                snowflake.style.setProperty('--drift', (Math.random() - 0.5) * 100 + 'px');
                
                snow.appendChild(snowflake);
            }
        }

        // Cursor trail effect
        document.addEventListener('mousemove', function(e) {
            if (Math.random() > 0.8) { // Only create trail sometimes for creepy effect
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = e.pageX + 'px';
                trail.style.top = e.pageY + 'px';
                document.body.appendChild(trail);
                
                setTimeout(() => {
                    document.body.removeChild(trail);
                }, 500);
            }
        });

        // Random text corruption
        function corruptText() {
            const textElements = document.querySelectorAll('.story-content p');
            const randomElement = textElements[Math.floor(Math.random() * textElements.length)];
            
            if (Math.random() > 0.95) { // Very rare corruption
                const originalText = randomElement.textContent;
                const corruptedText = originalText.split('').map(char => {
                    return Math.random() > 0.95 ? '█' : char;
                }).join('');
                
                randomElement.textContent = corruptedText;
                
                setTimeout(() => {
                    randomElement.innerHTML = originalText;
                }, 100);
            }
        }

        // Glitch/jitter the music-info popup even more, and add sound and text corruption
        function glitchMusicInfo() {
            const musicInfo = document.getElementById('musicInfo');
            if (!musicInfo.classList.contains('show')) return;
            // Randomly shift the popup position, scale, and rotate slightly
            if (Math.random() > 0.8) {
                const dx = (Math.random() - 0.5) * 12;
                const dy = (Math.random() - 0.5) * 10;
                const scale = 1 + (Math.random() - 0.5) * 0.08;
                const rot = (Math.random() - 0.5) * 2.5;
                musicInfo.style.transform = `translateY(0) scale(${scale}) skew(-1.5deg, 0deg) translate(${dx}px,${dy}px) rotate(${rot}deg)`;
            } else {
                musicInfo.style.transform = '';
            }
            // Chance to corrupt text with █ or weird Unicode
            if (Math.random() > 0.93) {
                let txt = musicInfo.getAttribute("data-text");
                const corruptionChars = ['█', '▓', '▒', '░', '͟', '̷', '̸', '͜', '͟', '͢', '͜', '͟', '͝', '͞', '͟', '͠'];
                let corrupted = '';
                for (let i = 0; i < txt.length; i++) {
                    if (Math.random() > 0.97) {
                        corrupted += corruptionChars[Math.floor(Math.random()*corruptionChars.length)];
                    } else {
                        corrupted += txt[i];
                    }
                }
                musicInfo.innerHTML = corrupted +
                    '<div class="music-info-scanlines"></div><div class="music-info-static"></div>';
            } else {
                // Reset to normal text
                musicInfo.innerHTML = musicInfo.getAttribute("data-text") +
                    '<div class="music-info-scanlines"></div><div class="music-info-static"></div>';
            }
            // Rarely play a static or noise burst (Web Audio API)
            if (Math.random() > 0.995 && window.AudioContext) {
                let ctx = window._staticCtx || (window._staticCtx = new (window.AudioContext || window.webkitAudioContext)());
                let buffer = ctx.createBuffer(1, 4096, ctx.sampleRate);
                let data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random()-0.5) * (Math.random() > 0.98 ? 2 : 0.35);
                }
                let src = ctx.createBufferSource();
                src.buffer = buffer;
                let gain = ctx.createGain();
                gain.gain.value = 0.15 + Math.random()*0.08;
                src.connect(gain).connect(ctx.destination);
                src.start(0);
                src.stop(ctx.currentTime + 0.06 + Math.random() * 0.13);
            }
        }

        // Initialize effects
        createSnow();
        setInterval(corruptText, 3000);
        setInterval(glitchMusicInfo, 80);

        // ---- Music system (copied/adapted from index.html) ----
        let musicPlaying = false;
        let userInteracted = false;
        const audio = document.getElementById('backgroundMusic');
        const musicToggle = document.getElementById('musicToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const musicInfo = document.getElementById('musicInfo');

        // Set initial volume (30%)
        audio.volume = 0.3;

        // Toggle music on/off
        musicToggle.addEventListener('click', function() {
            if (musicPlaying) {
                audio.pause();
                musicToggle.textContent = '♫ Music: OFF';
                musicToggle.classList.remove('playing');
                musicInfo.classList.remove('show');
                musicPlaying = false;
            } else {
                audio.play().then(() => {
                    musicToggle.textContent = '♫ Music: ON';
                    musicToggle.classList.add('playing');
                    musicInfo.classList.add('show');
                    // forcibly reset text to prevent stuck corruption
                    musicInfo.innerHTML = musicInfo.getAttribute("data-text") +
                        '<div class="music-info-scanlines"></div><div class="music-info-static"></div>';
                    musicPlaying = true;
                }).catch(e => {
                    console.log('Audio play failed:', e);
                });
            }
        });

        // Volume control
        volumeSlider.addEventListener('input', function() {
            audio.volume = this.value / 100;
        });

        // Auto-enable music on first user interaction
        document.addEventListener('click', function() {
            if (!userInteracted && !musicPlaying) {
                userInteracted = true;
                audio.play().then(() => {
                    musicToggle.textContent = '♫ Music: ON';
                    musicToggle.classList.add('playing');
                    musicInfo.classList.add('show');
                    musicInfo.innerHTML = musicInfo.getAttribute("data-text") +
                        '<div class="music-info-scanlines"></div><div class="music-info-static"></div>';
                    musicPlaying = true;
                }).catch(e => {
                    console.log('Auto-play failed:', e);
                });
            }
        }, { once: true });

        // Hide music info after 5 seconds
        audio.addEventListener('play', function() {
            setTimeout(() => {
                musicInfo.classList.remove('show');
            }, 5000);
        });

        // Handle audio errors
        audio.addEventListener('error', function() {
            musicToggle.textContent = '♫ Music: ERROR';
            console.log('Error loading audio file');
        });

        // Try to autoplay on load
        window.addEventListener('load', function() {
            audio.volume = 0.3;
            audio.play().then(() => {
                musicToggle.textContent = '♫ Music: ON';
                musicToggle.classList.add('playing');
                musicInfo.classList.add('show');
                musicInfo.innerHTML = musicInfo.getAttribute("data-text") +
                    '<div class="music-info-scanlines"></div><div class="music-info-static"></div>';
                musicPlaying = true;
            }).catch(function(error) {
                console.log('Autoplay prevented:', error);
            });
        });
    </script>
</body>
</html>
